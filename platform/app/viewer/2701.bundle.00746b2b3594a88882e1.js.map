{"version":3,"file":"2701.bundle.00746b2b3594a88882e1.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRMeasurementViewport.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/utils/formatContentItem.ts","webpack:///../../../extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRContentItem.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRContainer.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRTextViewport.tsx","webpack:///../../../extensions/cornerstone-dicom-sr/src/components/OHIFCornerstoneSRViewport.tsx"],"sourcesContent":["import PropTypes from 'prop-types';\nimport React, { useCallback, useContext, useEffect, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { ExtensionManager } from '@ohif/core';\n\nimport { setTrackingUniqueIdentifiersForElement } from '../tools/modules/dicomSRModule';\n\nimport { Icon, Tooltip, useViewportGrid, ViewportActionArrows } from '@ohif/ui';\nimport hydrateStructuredReport from '../utils/hydrateStructuredReport';\nimport { useAppConfig } from '@state';\nimport createReferencedImageDisplaySet from '../utils/createReferencedImageDisplaySet';\n\nconst MEASUREMENT_TRACKING_EXTENSION_ID = '@ohif/extension-measurement-tracking';\n\nconst SR_TOOLGROUP_BASE_NAME = 'SRToolGroup';\n\nfunction OHIFCornerstoneSRMeasurementViewport(props: withAppTypes) {\n  const {\n    commandsManager,\n    children,\n    dataSource,\n    displaySets,\n    viewportOptions,\n    servicesManager,\n    extensionManager,\n  } = props;\n\n  const [appConfig] = useAppConfig();\n\n  const {\n    displaySetService,\n    cornerstoneViewportService,\n    measurementService,\n    viewportActionCornersService,\n  } = servicesManager.services;\n\n  const viewportId = viewportOptions.viewportId;\n\n  // SR viewport will always have a single display set\n  if (displaySets.length > 1) {\n    throw new Error('SR viewport should only have a single display set');\n  }\n\n  const srDisplaySet = displaySets[0];\n\n  const [viewportGrid, viewportGridService] = useViewportGrid();\n  const [measurementSelected, setMeasurementSelected] = useState(0);\n  const [measurementCount, setMeasurementCount] = useState(1);\n  const [activeImageDisplaySetData, setActiveImageDisplaySetData] = useState(null);\n  const [referencedDisplaySetMetadata, setReferencedDisplaySetMetadata] = useState(null);\n  const [element, setElement] = useState(null);\n  const { viewports, activeViewportId } = viewportGrid;\n\n  const { t } = useTranslation('Common');\n\n  // Optional hook into tracking extension, if present.\n  let trackedMeasurements;\n  let sendTrackedMeasurementsEvent;\n\n  const hasMeasurementTrackingExtension = extensionManager.registeredExtensionIds.includes(\n    MEASUREMENT_TRACKING_EXTENSION_ID\n  );\n\n  if (hasMeasurementTrackingExtension) {\n    const contextModule = extensionManager.getModuleEntry(\n      '@ohif/extension-measurement-tracking.contextModule.TrackedMeasurementsContext'\n    );\n\n    const tracked = useContext(contextModule.context);\n    trackedMeasurements = tracked?.[0];\n    sendTrackedMeasurementsEvent = tracked?.[1];\n  }\n\n  if (!sendTrackedMeasurementsEvent) {\n    // if no panels from measurement-tracking extension is used, this code will run\n    trackedMeasurements = null;\n    sendTrackedMeasurementsEvent = (eventName, { displaySetInstanceUID }) => {\n      measurementService.clearMeasurements();\n      const { SeriesInstanceUIDs } = hydrateStructuredReport(\n        { servicesManager, extensionManager, appConfig },\n        displaySetInstanceUID\n      );\n\n      const displaySets = displaySetService.getDisplaySetsForSeries(SeriesInstanceUIDs[0]);\n      if (displaySets.length) {\n        viewportGridService.setDisplaySetsForViewports([\n          {\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [displaySets[0].displaySetInstanceUID],\n          },\n        ]);\n      }\n    };\n  }\n\n  /**\n   * Todo: what is this, not sure what it does regarding the react aspect,\n   * it is updating a local variable? which is not state.\n   */\n  const [isLocked, setIsLocked] = useState(trackedMeasurements?.context?.trackedSeries?.length > 0);\n  /**\n   * Store the tracking identifiers per viewport in order to be able to\n   * show the SR measurements on the referenced image on the correct viewport,\n   * when multiple viewports are used.\n   */\n  const setTrackingIdentifiers = useCallback(\n    measurementSelected => {\n      const { measurements } = srDisplaySet;\n\n      setTrackingUniqueIdentifiersForElement(\n        element,\n        measurements.map(measurement => measurement.TrackingUniqueIdentifier),\n        measurementSelected\n      );\n    },\n    [element, measurementSelected, srDisplaySet]\n  );\n\n  /**\n   * OnElementEnabled callback which is called after the cornerstoneExtension\n   * has enabled the element. Note: we delegate all the image rendering to\n   * cornerstoneExtension, so we don't need to do anything here regarding\n   * the image rendering, element enabling etc.\n   */\n  const onElementEnabled = evt => {\n    setElement(evt.detail.element);\n  };\n\n  const updateViewport = useCallback(\n    newMeasurementSelected => {\n      const { StudyInstanceUID, displaySetInstanceUID, sopClassUids } = srDisplaySet;\n\n      if (!StudyInstanceUID || !displaySetInstanceUID) {\n        return;\n      }\n\n      if (sopClassUids && sopClassUids.length > 1) {\n        // Todo: what happens if there are multiple SOP Classes? Why we are\n        // not throwing an error?\n        console.warn('More than one SOPClassUID in the same series is not yet supported.');\n      }\n\n      // if (!srDisplaySet.measurements || !srDisplaySet.measurements.length) {\n      //   return;\n      // }\n\n      _getViewportReferencedDisplaySetData(\n        srDisplaySet,\n        newMeasurementSelected,\n        displaySetService\n      ).then(({ referencedDisplaySet, referencedDisplaySetMetadata }) => {\n        if (!referencedDisplaySet || !referencedDisplaySetMetadata) {\n          return;\n        }\n\n        setMeasurementSelected(newMeasurementSelected);\n        setActiveImageDisplaySetData(referencedDisplaySet);\n        setReferencedDisplaySetMetadata(referencedDisplaySetMetadata);\n\n        if (\n          referencedDisplaySet.displaySetInstanceUID ===\n          activeImageDisplaySetData?.displaySetInstanceUID\n        ) {\n          const { measurements } = srDisplaySet;\n\n          // it means that we have a new referenced display set, and the\n          // imageIdIndex will handle it by updating the viewport, but if they\n          // are the same we just need to use measurementService to jump to the\n          // new measurement\n          const csViewport = cornerstoneViewportService.getCornerstoneViewport(viewportId);\n\n          if (!csViewport) {\n            return;\n          }\n\n          const imageIds = csViewport.getImageIds();\n\n          const imageIdIndex = imageIds.indexOf(measurements[newMeasurementSelected].imageId);\n\n          if (imageIdIndex !== -1) {\n            csViewport.setImageIdIndex(imageIdIndex);\n          }\n        }\n      });\n    },\n    [dataSource, srDisplaySet, activeImageDisplaySetData, viewportId]\n  );\n\n  const getCornerstoneViewport = useCallback(() => {\n    if (!activeImageDisplaySetData) {\n      return null;\n    }\n\n    const { component: Component } = extensionManager.getModuleEntry(\n      '@ohif/extension-cornerstone.viewportModule.cornerstone'\n    );\n\n    const { measurements } = srDisplaySet;\n    const measurement = measurements[measurementSelected];\n\n    if (!measurement) {\n      return null;\n    }\n\n    const initialImageIndex = activeImageDisplaySetData.images.findIndex(\n      image => image.imageId === measurement.imageId\n    );\n\n    return (\n      <Component\n        {...props}\n        // should be passed second since we don't want SR displaySet to\n        // override the activeImageDisplaySetData\n        displaySets={[activeImageDisplaySetData]}\n        // It is possible that there is a hanging protocol applying viewportOptions\n        // for the SR, so inherit the viewport options\n        // TODO: Ensure the viewport options are set correctly with respect to\n        // stack etc, in the incoming viewport options.\n        viewportOptions={{\n          ...viewportOptions,\n          toolGroupId: `${SR_TOOLGROUP_BASE_NAME}`,\n          // viewportType should not be required, as the stack type should be\n          // required already in order to view SR, but sometimes segmentation\n          // views set the viewport type without fixing the allowed display\n          viewportType: 'stack',\n          // The positionIds for the viewport aren't meaningful for the child display sets\n          positionIds: null,\n        }}\n        onElementEnabled={evt => {\n          props.onElementEnabled?.(evt);\n          onElementEnabled(evt);\n        }}\n        initialImageIndex={initialImageIndex}\n        isJumpToMeasurementDisabled={true}\n      ></Component>\n    );\n  }, [activeImageDisplaySetData, viewportId, measurementSelected]);\n\n  const onMeasurementChange = useCallback(\n    direction => {\n      let newMeasurementSelected = measurementSelected;\n\n      newMeasurementSelected += direction;\n      if (newMeasurementSelected >= measurementCount) {\n        newMeasurementSelected = 0;\n      } else if (newMeasurementSelected < 0) {\n        newMeasurementSelected = measurementCount - 1;\n      }\n\n      setTrackingIdentifiers(newMeasurementSelected);\n      updateViewport(newMeasurementSelected);\n    },\n    [measurementSelected, measurementCount, updateViewport, setTrackingIdentifiers]\n  );\n\n  /**\n   Cleanup the SR viewport when the viewport is destroyed\n   */\n  useEffect(() => {\n    const onDisplaySetsRemovedSubscription = displaySetService.subscribe(\n      displaySetService.EVENTS.DISPLAY_SETS_REMOVED,\n      ({ displaySetInstanceUIDs }) => {\n        const activeViewport = viewports.get(activeViewportId);\n        if (displaySetInstanceUIDs.includes(activeViewport.displaySetInstanceUID)) {\n          viewportGridService.setDisplaySetsForViewport({\n            viewportId: activeViewportId,\n            displaySetInstanceUIDs: [],\n          });\n        }\n      }\n    );\n\n    return () => {\n      onDisplaySetsRemovedSubscription.unsubscribe();\n    };\n  }, []);\n\n  /**\n   * Loading the measurements from the SR viewport, which goes through the\n   * isHydratable check, the outcome for the isHydrated state here is always FALSE\n   * since we don't do the hydration here. Todo: can't we just set it as false? why\n   * we are changing the state here? isHydrated is always false at this stage, and\n   * if it is hydrated we don't even use the SR viewport.\n   */\n  useEffect(() => {\n    const loadSR = async () => {\n      if (!srDisplaySet.isLoaded) {\n        await srDisplaySet.load();\n      }\n      const numMeasurements = srDisplaySet.measurements.length;\n      setMeasurementCount(numMeasurements);\n      updateViewport(measurementSelected);\n    };\n    loadSR();\n  }, [srDisplaySet]);\n\n  /**\n   * Hook to update the tracking identifiers when the selected measurement changes or\n   * the element changes\n   */\n  useEffect(() => {\n    const updateSR = async () => {\n      if (!srDisplaySet.isLoaded) {\n        await srDisplaySet.load();\n      }\n      if (!element || !srDisplaySet.isLoaded) {\n        return;\n      }\n      setTrackingIdentifiers(measurementSelected);\n    };\n    updateSR();\n  }, [measurementSelected, element, setTrackingIdentifiers, srDisplaySet]);\n\n  useEffect(() => {\n    setIsLocked(trackedMeasurements?.context?.trackedSeries?.length > 0);\n  }, [trackedMeasurements]);\n\n  useEffect(() => {\n    viewportActionCornersService.addComponents([\n      {\n        viewportId,\n        id: 'viewportStatusComponent',\n        component: _getStatusComponent({\n          srDisplaySet,\n          viewportId,\n          isRehydratable: srDisplaySet.isRehydratable,\n          isLocked,\n          sendTrackedMeasurementsEvent,\n          t,\n        }),\n        indexPriority: -100,\n        location: viewportActionCornersService.LOCATIONS.topLeft,\n      },\n      {\n        viewportId,\n        id: 'viewportActionArrowsComponent',\n        index: 0,\n        component: (\n          <ViewportActionArrows\n            key=\"actionArrows\"\n            onArrowsClick={onMeasurementChange}\n          ></ViewportActionArrows>\n        ),\n        indexPriority: 0,\n        location: viewportActionCornersService.LOCATIONS.topRight,\n      },\n    ]);\n  }, [\n    isLocked,\n    onMeasurementChange,\n    sendTrackedMeasurementsEvent,\n    srDisplaySet,\n    t,\n    viewportActionCornersService,\n    viewportId,\n  ]);\n\n  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n  let childrenWithProps = null;\n\n  if (!activeImageDisplaySetData || !referencedDisplaySetMetadata) {\n    return null;\n  }\n\n  if (children && children.length) {\n    childrenWithProps = children.map((child, index) => {\n      return (\n        child &&\n        React.cloneElement(child, {\n          viewportId,\n          key: index,\n        })\n      );\n    });\n  }\n\n  return (\n    <>\n      <div className=\"relative flex h-full w-full flex-row overflow-hidden\">\n        {getCornerstoneViewport()}\n        {childrenWithProps}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSRMeasurementViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n  servicesManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nasync function _getViewportReferencedDisplaySetData(\n  displaySet,\n  measurementSelected,\n  displaySetService\n) {\n  const { measurements } = displaySet;\n  const measurement = measurements[measurementSelected];\n\n  const { displaySetInstanceUID } = measurement;\n  if (!displaySet.keyImageDisplaySet) {\n    // Create a new display set, and preserve a reference to it here,\n    // so that it can be re-displayed and shown inside the SR viewport.\n    // This is only for ease of redisplay - the display set is stored in the\n    // usual manner in the display set service.\n    displaySet.keyImageDisplaySet = createReferencedImageDisplaySet(displaySetService, displaySet);\n  }\n\n  if (!displaySetInstanceUID) {\n    return { referencedDisplaySetMetadata: null, referencedDisplaySet: null };\n  }\n\n  const referencedDisplaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\n\n  const image0 = referencedDisplaySet.images[0];\n  const referencedDisplaySetMetadata = {\n    PatientID: image0.PatientID,\n    PatientName: image0.PatientName,\n    PatientSex: image0.PatientSex,\n    PatientAge: image0.PatientAge,\n    SliceThickness: image0.SliceThickness,\n    StudyDate: image0.StudyDate,\n    SeriesDescription: image0.SeriesDescription,\n    SeriesInstanceUID: image0.SeriesInstanceUID,\n    SeriesNumber: image0.SeriesNumber,\n    ManufacturerModelName: image0.ManufacturerModelName,\n    SpacingBetweenSlices: image0.SpacingBetweenSlices,\n  };\n\n  return { referencedDisplaySetMetadata, referencedDisplaySet };\n}\n\nfunction _getStatusComponent({\n  srDisplaySet,\n  viewportId,\n  isRehydratable,\n  isLocked,\n  sendTrackedMeasurementsEvent,\n  t,\n}) {\n  const handleMouseUp = () => {\n    sendTrackedMeasurementsEvent('HYDRATE_SR', {\n      displaySetInstanceUID: srDisplaySet.displaySetInstanceUID,\n      viewportId,\n    });\n  };\n\n  const loadStr = t('LOAD');\n\n  // 1 - Incompatible\n  // 2 - Locked\n  // 3 - Rehydratable / Open\n  const state = isRehydratable && !isLocked ? 3 : isRehydratable && isLocked ? 2 : 1;\n  let ToolTipMessage = null;\n  let StatusIcon = null;\n\n  switch (state) {\n    case 1:\n      StatusIcon = () => <Icon name=\"status-alert\" />;\n\n      ToolTipMessage = () => (\n        <div>\n          This structured report is not compatible\n          <br />\n          with this application.\n        </div>\n      );\n      break;\n    case 2:\n      StatusIcon = () => <Icon name=\"status-locked\" />;\n\n      ToolTipMessage = () => (\n        <div>\n          This structured report is currently read-only\n          <br />\n          because you are tracking measurements in\n          <br />\n          another viewport.\n        </div>\n      );\n      break;\n    case 3:\n      StatusIcon = () => (\n        <Icon\n          className=\"text-aqua-pale\"\n          name=\"status-untracked\"\n        />\n      );\n\n      ToolTipMessage = () => <div>{`Click ${loadStr} to restore measurements.`}</div>;\n  }\n\n  const StatusArea = () => (\n    <div className=\"flex h-6 cursor-default text-sm leading-6 text-white\">\n      <div className=\"bg-customgray-100 flex min-w-[45px] items-center rounded-l-xl rounded-r p-1\">\n        <StatusIcon />\n        <span className=\"ml-1\">SR</span>\n      </div>\n      {state === 3 && (\n        <div\n          className=\"bg-primary-main hover:bg-primary-light ml-1 cursor-pointer rounded px-1.5 hover:text-black\"\n          // Using onMouseUp here because onClick is not working when the viewport is not active and is styled with pointer-events:none\n          onMouseUp={handleMouseUp}\n        >\n          {loadStr}\n        </div>\n      )}\n    </div>\n  );\n\n  return (\n    <>\n      {ToolTipMessage && (\n        <Tooltip\n          content={<ToolTipMessage />}\n          position=\"bottom-left\"\n        >\n          <StatusArea />\n        </Tooltip>\n      )}\n      {!ToolTipMessage && <StatusArea />}\n    </>\n  );\n}\n\nexport default OHIFCornerstoneSRMeasurementViewport;\n","import { utils } from '@ohif/core';\n\n/**\n * Formatters used to format each of the content items (SR \"nodes\") which can be\n * text, code, UID ref, number, person name, date, time and date time. Each\n * formatter must be a function with the following signature:\n *\n *    [VALUE_TYPE]: (contentItem) => string\n *\n */\nconst contentItemFormatters = {\n  TEXT: contentItem => contentItem.TextValue,\n  CODE: contentItem => contentItem.ConceptCodeSequence?.[0]?.CodeMeaning,\n  UIDREF: contentItem => contentItem.UID,\n  NUM: contentItem => {\n    const measuredValue = contentItem.MeasuredValueSequence?.[0];\n\n    if (!measuredValue) {\n      return;\n    }\n\n    const { NumericValue, MeasurementUnitsCodeSequence } = measuredValue;\n    const { CodeValue } = MeasurementUnitsCodeSequence;\n\n    return `${NumericValue} ${CodeValue}`;\n  },\n  PNAME: contentItem => {\n    const personName = contentItem.PersonName?.[0]?.Alphabetic;\n    return personName ? utils.formatPN(personName) : undefined;\n  },\n  DATE: contentItem => {\n    const { Date } = contentItem;\n    return Date ? utils.formatDate(Date) : undefined;\n  },\n  TIME: contentItem => {\n    const { Time } = contentItem;\n    return Time ? utils.formatTime(Time) : undefined;\n  },\n  DATETIME: contentItem => {\n    const { DateTime } = contentItem;\n\n    if (typeof DateTime !== 'string') {\n      return;\n    }\n\n    // 14 characters because it should be something like 20180614113714\n    if (DateTime.length < 14) {\n      return DateTime;\n    }\n\n    const dicomDate = DateTime.substring(0, 8);\n    const dicomTime = DateTime.substring(8, 14);\n    const formattedDate = utils.formatDate(dicomDate);\n    const formattedTime = utils.formatTime(dicomTime);\n\n    return `${formattedDate} ${formattedTime}`;\n  },\n};\n\nfunction formatContentItemValue(contentItem) {\n  const { ValueType } = contentItem;\n  const fnFormat = contentItemFormatters[ValueType];\n\n  return fnFormat ? fnFormat(contentItem) : `[${ValueType} is not supported]`;\n}\n\nexport { formatContentItemValue as default, formatContentItemValue };\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { CodeNameCodeSequenceValues } from '../enums';\nimport formatContentItemValue from '../utils/formatContentItem';\n\nconst EMPTY_TAG_VALUE = '[empty]';\n\nfunction OHIFCornerstoneSRContentItem(props) {\n  const { contentItem, nodeIndexesTree, continuityOfContent } = props;\n  const { ConceptNameCodeSequence } = contentItem;\n  const { CodeValue, CodeMeaning } = ConceptNameCodeSequence;\n  const isChildFirstNode = nodeIndexesTree[nodeIndexesTree.length - 1] === 0;\n  const formattedValue = formatContentItemValue(contentItem) ?? EMPTY_TAG_VALUE;\n  const startWithAlphaNumCharRegEx = /^[a-zA-Z0-9]/;\n  const isContinuous = continuityOfContent === 'CONTINUOUS';\n  const isFinding = CodeValue === CodeNameCodeSequenceValues.Finding;\n  const addExtraSpace =\n    isContinuous && !isChildFirstNode && startWithAlphaNumCharRegEx.test(formattedValue?.[0]);\n\n  // Collapse sequences of white space preserving newline characters\n  let className = 'whitespace-pre-line';\n\n  if (CodeValue === CodeNameCodeSequenceValues.Finding) {\n    // Preserve spaces because it is common to see tabular text in a\n    // \"Findings\" ConceptNameCodeSequence\n    className = 'whitespace-pre-wrap';\n  }\n\n  if (isContinuous) {\n    return (\n      <>\n        <span\n          className={className}\n          title={CodeMeaning}\n        >\n          {addExtraSpace ? ' ' : ''}\n          {formattedValue}\n        </span>\n      </>\n    );\n  }\n\n  return (\n    <>\n      <div className=\"mb-2\">\n        <span className=\"font-bold\">{CodeMeaning}: </span>\n        {isFinding ? (\n          <pre>{formattedValue}</pre>\n        ) : (\n          <span className={className}>{formattedValue}</span>\n        )}\n      </div>\n    </>\n  );\n}\n\nOHIFCornerstoneSRContentItem.propTypes = {\n  contentItem: PropTypes.object,\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\n  continuityOfContent: PropTypes.string,\n};\n\nexport { OHIFCornerstoneSRContentItem };\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { OHIFCornerstoneSRContentItem } from './OHIFCornerstoneSRContentItem';\n\nexport function OHIFCornerstoneSRContainer(props) {\n  const { container, nodeIndexesTree = [0], containerNumberedTree = [1] } = props;\n  const { ContinuityOfContent, ConceptNameCodeSequence } = container;\n  const { CodeMeaning } = ConceptNameCodeSequence ?? {};\n  let childContainerIndex = 1;\n  const contentItems = container.ContentSequence?.map((contentItem, i) => {\n    const { ValueType } = contentItem;\n    const childNodeLevel = [...nodeIndexesTree, i];\n    const key = childNodeLevel.join('.');\n\n    let Component;\n    let componentProps;\n\n    if (ValueType === 'CONTAINER') {\n      const childContainerNumberedTree = [...containerNumberedTree, childContainerIndex++];\n\n      Component = OHIFCornerstoneSRContainer;\n      componentProps = {\n        container: contentItem,\n        nodeIndexesTree: childNodeLevel,\n        containerNumberedTree: childContainerNumberedTree,\n      };\n    } else {\n      Component = OHIFCornerstoneSRContentItem;\n      componentProps = {\n        contentItem,\n        nodeIndexesTree: childNodeLevel,\n        continuityOfContent: ContinuityOfContent,\n      };\n    }\n\n    return (\n      <Component\n        key={key}\n        {...componentProps}\n      />\n    );\n  });\n\n  return (\n    <div>\n      <div className=\"font-bold\">\n        {containerNumberedTree.join('.')}.&nbsp;\n        {CodeMeaning}\n      </div>\n      <div className=\"ml-4 mb-2\">{contentItems}</div>\n    </div>\n  );\n}\n\nOHIFCornerstoneSRContainer.propTypes = {\n  /**\n   * A tree node that may contain another container or one or more content items\n   * (text, code, uidref, pname, etc.)\n   */\n  container: PropTypes.object,\n  /**\n   * A 0-based index list\n   */\n  nodeIndexesTree: PropTypes.arrayOf(PropTypes.number),\n  /**\n   * A 1-based index list that represents a container in a multi-level numbered\n   * list (tree).\n   *\n   * Example:\n   *  1. History\n   *    1.1. Chief Complaint\n   *    1.2. Present Illness\n   *    1.3. Past History\n   *    1.4. Family History\n   *  2. Findings\n   * */\n  containerNumberedTree: PropTypes.arrayOf(PropTypes.number),\n};\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ExtensionManager } from '@ohif/core';\nimport { OHIFCornerstoneSRContainer } from './OHIFCornerstoneSRContainer';\n\nfunction OHIFCornerstoneSRTextViewport(props: withAppTypes) {\n  const { displaySets } = props;\n  const displaySet = displaySets[0];\n  const instance = displaySet.instances[0];\n\n  return (\n    <div className=\"relative flex h-full w-full flex-col overflow-auto p-4 text-white\">\n      <div>\n        {/* The root level is always a container */}\n        <OHIFCornerstoneSRContainer container={instance} />\n      </div>\n    </div>\n  );\n}\n\nOHIFCornerstoneSRTextViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n  servicesManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nexport default OHIFCornerstoneSRTextViewport;\n","import PropTypes from 'prop-types';\nimport React from 'react';\nimport { ExtensionManager } from '@ohif/core';\n\nimport OHIFCornerstoneSRMeasurementViewport from './OHIFCornerstoneSRMeasurementViewport';\nimport OHIFCornerstoneSRTextViewport from './OHIFCornerstoneSRTextViewport';\n\nfunction OHIFCornerstoneSRViewport(props: withAppTypes) {\n  const { displaySets } = props;\n  const { isImagingMeasurementReport } = displaySets[0];\n\n  if (isImagingMeasurementReport) {\n    return <OHIFCornerstoneSRMeasurementViewport {...props}></OHIFCornerstoneSRMeasurementViewport>;\n  }\n\n  return <OHIFCornerstoneSRTextViewport {...props}></OHIFCornerstoneSRTextViewport>;\n}\n\nOHIFCornerstoneSRViewport.propTypes = {\n  displaySets: PropTypes.arrayOf(PropTypes.object),\n  viewportId: PropTypes.string.isRequired,\n  dataSource: PropTypes.object,\n  children: PropTypes.node,\n  viewportLabel: PropTypes.string,\n  viewportOptions: PropTypes.object,\n  servicesManager: PropTypes.object.isRequired,\n  extensionManager: PropTypes.instanceOf(ExtensionManager).isRequired,\n};\n\nexport default OHIFCornerstoneSRViewport;\n"],"names":["OHIFCornerstoneSRMeasurementViewport","props","commandsManager","children","dataSource","displaySets","viewportOptions","servicesManager","extensionManager","appConfig","useAppConfig","displaySetService","cornerstoneViewportService","measurementService","viewportActionCornersService","services","viewportId","length","Error","srDisplaySet","viewportGrid","viewportGridService","useViewportGrid","measurementSelected","setMeasurementSelected","useState","measurementCount","setMeasurementCount","activeImageDisplaySetData","setActiveImageDisplaySetData","referencedDisplaySetMetadata","setReferencedDisplaySetMetadata","element","setElement","viewports","activeViewportId","t","useTranslation","trackedMeasurements","sendTrackedMeasurementsEvent","registeredExtensionIds","includes","contextModule","getModuleEntry","tracked","useContext","context","eventName","displaySetInstanceUID","clearMeasurements","SeriesInstanceUIDs","hydrateStructuredReport","getDisplaySetsForSeries","setDisplaySetsForViewports","displaySetInstanceUIDs","isLocked","setIsLocked","trackedSeries","setTrackingIdentifiers","useCallback","measurements","setTrackingUniqueIdentifiersForElement","map","measurement","TrackingUniqueIdentifier","updateViewport","newMeasurementSelected","StudyInstanceUID","sopClassUids","console","warn","async","displaySet","keyImageDisplaySet","createReferencedImageDisplaySet","referencedDisplaySet","getDisplaySetByUID","image0","images","PatientID","PatientName","PatientSex","PatientAge","SliceThickness","StudyDate","SeriesDescription","SeriesInstanceUID","SeriesNumber","ManufacturerModelName","SpacingBetweenSlices","_getViewportReferencedDisplaySetData","then","csViewport","getCornerstoneViewport","imageIdIndex","getImageIds","indexOf","imageId","setImageIdIndex","component","Component","initialImageIndex","findIndex","image","React","_extends","toolGroupId","viewportType","positionIds","onElementEnabled","evt","detail","isJumpToMeasurementDisabled","onMeasurementChange","direction","useEffect","onDisplaySetsRemovedSubscription","subscribe","EVENTS","DISPLAY_SETS_REMOVED","activeViewport","get","setDisplaySetsForViewport","unsubscribe","isLoaded","load","numMeasurements","loadSR","updateSR","addComponents","id","_getStatusComponent","isRehydratable","indexPriority","location","LOCATIONS","topLeft","index","ViewportActionArrows","key","onArrowsClick","topRight","childrenWithProps","child","className","handleMouseUp","loadStr","state","ToolTipMessage","StatusIcon","Icon","name","StatusArea","onMouseUp","Tooltip","content","position","propTypes","PropTypes","isRequired","viewportLabel","ExtensionManager","contentItemFormatters","TEXT","contentItem","TextValue","CODE","ConceptCodeSequence","CodeMeaning","UIDREF","UID","NUM","measuredValue","MeasuredValueSequence","NumericValue","MeasurementUnitsCodeSequence","CodeValue","PNAME","personName","PersonName","Alphabetic","utils","formatPN","undefined","DATE","Date","formatDate","TIME","Time","formatTime","DATETIME","DateTime","dicomDate","substring","dicomTime","EMPTY_TAG_VALUE","OHIFCornerstoneSRContentItem","nodeIndexesTree","continuityOfContent","ConceptNameCodeSequence","isChildFirstNode","formattedValue","ValueType","fnFormat","formatContentItemValue","isContinuous","isFinding","CodeNameCodeSequenceValues","Finding","addExtraSpace","test","title","OHIFCornerstoneSRContainer","container","containerNumberedTree","ContinuityOfContent","childContainerIndex","contentItems","ContentSequence","i","childNodeLevel","join","componentProps","OHIFCornerstoneSRTextViewport","instance","instances","OHIFCornerstoneSRViewport","isImagingMeasurementReport"],"sourceRoot":""}